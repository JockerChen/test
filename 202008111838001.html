<!--
 * @Author: [JokerChen]
 * @Date: 2020-08-11 18:38:38
 * @LastEditors: [JokerChen]
 * @LastEditTime: 2020-08-11 19:01:56
 * @Description: 
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>二维码读头解密</title>
</head>
<body>
  
</body>
</html>
<script>
window.onload=function(){
  //加密部分
  // var cardid = "3512265146";
  // var currentTime = Date.parse(new Date());//当前日期
  // var slider3 = 0; //0小时
  // var slider4 = 10; //10分钟
  // var time = currentTime + (slider3 * 60 + slider4) * 60 * 1000;//毫秒
  // var count = 2; //次数 0次为不限次 
  // var sCard = getQrcodeBytes(cardid, time, count);
  // console.log(sCard);
  
  //解密
  console.log(qrDeCodeProject("F1204538C11C5F32A9AB6D5B6709E7E4218C4681"));
  
}

/*-----------------------解密------------------------------*/

function getArr(str) {
    var arr = []
    for (var i = 0; i < str.length; i += 2) {
        arr.push('0x' + str[i] + str[i + 1])
    }
    return arr.map(function (x) {
        return parseInt(x)
    })
}
function toSeekId(bs) {
    var value =
      (bs[0] & 0xFF) << 24 |
      (bs[1] & 0xFF) << 16 |
      (bs[2] & 0xFF) << 8 |
      (bs[3] & 0xFF) << 0;
    return value;
}
//字符串转字节
function deStringToByte(str) {
    var bytes = new Array();
    var len, c;
    len = str.length;
    for (var i = 0; i < len; i++) {
        c = str.charCodeAt(i);
        if (c >= 0x010000 && c <= 0x10FFFF) {
            bytes.push(((c >> 18) & 0x07) | 0xF0);
            bytes.push(((c >> 12) & 0x3F) | 0x80);
            bytes.push(((c >> 6) & 0x3F) | 0x80);
            bytes.push((c & 0x3F) | 0x80);
        } else if (c >= 0x000800 && c <= 0x00FFFF) {
            bytes.push(((c >> 12) & 0x0F) | 0xE0);
            bytes.push(((c >> 6) & 0x3F) | 0x80);
            bytes.push((c & 0x3F) | 0x80);
        } else if (c >= 0x000080 && c <= 0x0007FF) {
            bytes.push(((c >> 6) & 0x1F) | 0xC0);
            bytes.push((c & 0x3F) | 0x80);
        } else {
            bytes.push(c & 0xFF);
        }
    }
    return bytes;
}
function deHloveyRC4(aInput, aKey) {
    var iS = new Array(256);
    var iK = new Array(256);

    for (var i = 0; i < 256; i++) {
        iS[i] = i;
    }

    var j = 1;
    for (var i = 0; i < 256; i++) {
        iK[i] = aKey[(i % aKey.length)];
    }
    j = 0;
    for (var i = 0; i < 256; i++) {
        j = (j + iS[i] + iK[i]) % 256;
        var temp = iS[i];
        iS[i] = iS[j];
        iS[j] = temp;
    }
    var i = 0;
    j = 0;
    var iInputBytes = aInput;
    var iOutputBytes = new Array(aInput.length);
    for (var x = 0; x < iInputBytes.length; x++) {
        i = (i + 1) % 256;
        j = (j + iS[i]) % 256;
        var temp = iS[i];
        iS[i] = iS[j];
        iS[j] = temp;
        //int t = (iS[i]+(iS[j] % 256)) % 256;     
        var t = (iS[i] + iS[j]) % 256;
        var iY = iS[t];
        var iCY = iY;
        iOutputBytes[x] = (iInputBytes[x] ^ iCY) & 0xFF;
    }
    return iOutputBytes;
}
//调用解密的函数
//调用解密的函数
function qrDeCodeProject(codeString) {
    var byte4 = [];
    var byte4Time = [];
    var arr = getArr(codeString);
    var keys = deStringToByte("RCQJVAGOSZXOYVXCVQYFORCTOTZKYESE");
    var seekByte20 = deHloveyRC4(arr, keys);
    for (var i = 4; i < 8; i++) {
        byte4.push(seekByte20[i]);
    }
    for (var i = 12; i < 16; i++) {
        byte4Time.push(seekByte20[i]);
    }
    if (toSeekId(byte4) > 0) {
        var seekId = toSeekId(byte4).toString();
    } else {
        var seekId = (4294967296 + toSeekId(byte4)).toString();
    }
    //4294967296 - seekId
    if (seekId.length < 10) {
        var subStr = ""
        for (var j = 0; j < 10 - seekId.length; j++) {
            subStr += "0"
        }
        seekId = subStr + seekId
    }
    var currentTime = toSeekId(byte4Time) * 1000;
    return seekId + ' ' + currentTime
}
//num传入的数字，n需要的字符长度
function PrefixInteger(num, n) {
    return (Array(n).join(0) + num).slice(-n);
}
/*------------------------解密结束--------------------------------------*/



// //二维码加密函数
// /*_______________________________________________________*/

// //获取二维码头
// function long_byte4(value) {
//     var result = new Array(4);
//     result[0] = (value >> 24 & 0xFF);
//     result[1] = (value >> 16 & 0xFF);
//     result[2] = (value >> 8 & 0xFF);
//     result[3] = (value >> 0 & 0xFF);
//     return result;
// }

// function byte4_long(bs) {
//     var value =
//       (bs[3] & 0xFF) << 24 |
//       (bs[2] & 0xFF) << 16 |
//       (bs[1] & 0xFF) << 8 |
//       (bs[0] & 0xFF) << 0;
//     return value;
// }

// //CRC校验
// function CrcGen_STM32(data, size) {
//     var j;
//     var i;
//     var temp;
//     var crc = 0x16E008EC; //请联系厂家获取crc初值
//     for (i = 0; i < size; i++) {
//         var t = new Array(4);

//         var index = i * 4;
//         for (var k = 0; k < 4; k++) {
//             t[k] = data[index++];
//         }

//         temp = byte4_long(t);

//         for (j = 0; j < 32; j++) {
//             if (((crc ^ temp) & 0x80000000) != 0) {
//                 crc = 0x04C11DB7 ^ (crc << 1);
//             } else {
//                 crc <<= 1;
//             }
//             temp <<= 1;
//         }
//     }
//     return crc;
// }
// //字符串转字节
// function stringToByte(str) {
//     var bytes = new Array();
//     var len, c;
//     len = str.length;
//     for (var i = 0; i < len; i++) {
//         c = str.charCodeAt(i);
//         if (c >= 0x010000 && c <= 0x10FFFF) {
//             bytes.push(((c >> 18) & 0x07) | 0xF0);
//             bytes.push(((c >> 12) & 0x3F) | 0x80);
//             bytes.push(((c >> 6) & 0x3F) | 0x80);
//             bytes.push((c & 0x3F) | 0x80);
//         } else if (c >= 0x000800 && c <= 0x00FFFF) {
//             bytes.push(((c >> 12) & 0x0F) | 0xE0);
//             bytes.push(((c >> 6) & 0x3F) | 0x80);
//             bytes.push((c & 0x3F) | 0x80);
//         } else if (c >= 0x000080 && c <= 0x0007FF) {
//             bytes.push(((c >> 6) & 0x1F) | 0xC0);
//             bytes.push((c & 0x3F) | 0x80);
//         } else {
//             bytes.push(c & 0xFF);
//         }
//     }
//     return bytes;
// }


// //cardid：需要加密的卡号,time:截止日期，count：次数 0次为无限次
// function getQrcodeBytes(cardid, time, count) {

//     var index = 0;
//     var qrcodebyte = new Array(20);

//     qrcodebyte[index++] = 0x26;// 头
//     qrcodebyte[index++] = 0x18;// 头
//     qrcodebyte[index++] = 0x01;// CMD
//     qrcodebyte[index++] = 0x0C;// 长

//     // ID 4
//     var b_cardid = long_byte4(cardid);
//     for (var i = 0; i < 4; i++) {
//         qrcodebyte[index++] = b_cardid[i]
//     }

//     // 厂商 3 + count 1
//     var b_company = new Array(0XFF, 0XFF, 0XFF, count);
//     for (var i = 0; i < 4; i++) {
//         qrcodebyte[index++] = b_company[i]
//     }

//     // TIME 4
//     var b_time = long_byte4(time / 1000);
//     for (var i = 0; i < 4; i++) {
//         qrcodebyte[index++] = b_time[i]
//     }

//     // crc32 4
//     var crcCheck = new Array(16);
//     for (var i = 0; i < 16; i++) {
//         crcCheck[i] = qrcodebyte[i]

//     }
//     var crcValue = CrcGen_STM32(crcCheck, 4);

//     var b_crc = long_byte4(crcValue);
//     for (var i = 0; i < 4; i++) {
//         qrcodebyte[index++] = b_crc[i]
//     }
    
//     var qrcode = HloveyRC4(qrcodebyte);
//     return qrcode;
// }



// function HloveyRC4(aInput) {
//     //暂时为死的key
//     var aKey = stringToByte("RCQJVAGOSZXOYVXCVQYFORCTOTZKYESE");
//     var iS = new Array(256);
//     var iK = new Array(256);

//     for (var i = 0; i < 256; i++) {
//         iS[i] = i;
//     }

//     var j = 1;
//     for (var i = 0; i < 256; i++) {
//         iK[i] = aKey[(i % aKey.length)];
//     }
//     j = 0;
//     for (var i = 0; i < 256; i++) {
//         j = (j + iS[i] + iK[i]) % 256;
//         var temp = iS[i];
//         iS[i] = iS[j];
//         iS[j] = temp;
//     }
//     var i = 0;
//     j = 0;
//     var iInputBytes = aInput;
//     var iOutputBytes = new Array(aInput.length);
//     for (var x = 0; x < iInputBytes.length; x++) {
//         i = (i + 1) % 256;
//         j = (j + iS[i]) % 256;
//         var temp = iS[i];
//         iS[i] = iS[j];
//         iS[j] = temp;
//         //int t = (iS[i]+(iS[j] % 256)) % 256;     
//         var t = (iS[i] + iS[j]) % 256;
//         var iY = iS[t];
//         var iCY = iY;
//         iOutputBytes[x] = (iInputBytes[x] ^ iCY) & 0xFF;
//     }
//     var sgetHexString = getHexString(iOutputBytes);
//     return sgetHexString;
// }


// //获取hex字符串
// function getHexString(seekByte20) {
//     if (seekByte20 == null || seekByte20.length == 0) {
//         return "";
//     }
//     var chars = new Array("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F");
//     var bit;
//     var sb = "";
//     for (var i = 0; i < seekByte20.length; i++) {
//         bit = (seekByte20[i] & 0x0f0) >> 4;
//         sb += (chars[bit]);
//         bit = seekByte20[i] & 0x0f;
//         sb += (chars[bit]);
//     }
//     return sb;
// }
// /*_______________________________________________________*/

</script>